<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ö–∏–±–µ—Ä–ø–∞–Ω–∫ –¢–µ—Ç—Ä–∏—Å</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://kit.fontawesome.com/a076d05399.js" crossorigin="anonymous"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Quantico:ital,wght@0,400;0,700;1,400&display=swap');
        
        :root {
            --neon-pink: #ff2a6d;
            --neon-blue: #05d9e8;
            --neon-purple: #d300c5;
            --dark-bg: #0d0221;
            --darker-bg: #050110;
        }
        
        body {
            font-family: 'Quantico', sans-serif;
            background-color: var(--dark-bg);
            color: var(--neon-blue);
            overflow: hidden;
            background-image: 
                radial-gradient(circle at 10% 20%, rgba(5, 217, 232, 0.03) 0%, transparent 20%),
                radial-gradient(circle at 90% 80%, rgba(213, 0, 197, 0.03) 0%, transparent 20%),
                linear-gradient(to bottom, var(--darker-bg), var(--dark-bg));
        }
        
        h1, h2, h3 {
            font-family: 'Orbitron', sans-serif;
            text-shadow: 0 0 5px var(--neon-blue), 0 0 10px var(--neon-blue);
        }
        
        .neon-text-pink {
            color: var(--neon-pink);
            text-shadow: 0 0 5px var(--neon-pink), 0 0 10px var(--neon-pink);
        }
        
        .neon-text-blue {
            color: var(--neon-blue);
            text-shadow: 0 0 5px var(--neon-blue), 0 0 10px var(--neon-blue);
        }
        
        .neon-border-blue {
            border: 2px solid var(--neon-blue);
            box-shadow: 0 0 10px var(--neon-blue), inset 0 0 10px var(--neon-blue);
        }
        
        .neon-border-pink {
            border: 2px solid var(--neon-pink);
            box-shadow: 0 0 10px var(--neon-pink), inset 0 0 10px var(--neon-pink);
        }
        
        .grid-cell {
            width: 30px;
            height: 30px;
            border: 1px solid rgba(5, 217, 232, 0.1);
            box-sizing: border-box;
        }
        
        .piece-i {
            background-color: #00f7ff;
            box-shadow: 0 0 10px #00f7ff, inset 0 0 5px #00f7ff;
        }
        
        .piece-j {
            background-color: #0d00ff;
            box-shadow: 0 0 10px #0d00ff, inset 0 0 5px #0d00ff;
        }
        
        .piece-l {
            background-color: #ff8800;
            box-shadow: 0 0 10px #ff8800, inset 0 0 5px #ff8800;
        }
        
        .piece-o {
            background-color: #ffee00;
            box-shadow: 0 0 10px #ffee00, inset 0 0 5px #ffee00;
        }
        
        .piece-s {
            background-color: #00ff4c;
            box-shadow: 0 0 10px #00ff4c, inset 0 0 5px #00ff4c;
        }
        
        .piece-t {
            background-color: #b700ff;
            box-shadow: 0 0 10px #b700ff, inset 0 0 5px #b700ff;
        }
        
        .piece-z {
            background-color: #ff0000;
            box-shadow: 0 0 10px #ff0000, inset 0 0 5px #ff0000;
        }
        
        .piece-ghost {
            opacity: 0.4;
            filter: brightness(2);
        }
        
        .scanline {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                to bottom,
                transparent 0%,
                rgba(5, 217, 232, 0.03) 50%,
                transparent 100%
            );
            background-size: 100% 4px;
            animation: scanline 8s linear infinite;
            pointer-events: none;
            z-index: 100;
        }
        
        @keyframes scanline {
            0% { transform: translateY(0); }
            100% { transform: translateY(100vh); }
        }
        
        .glow {
            animation: glow 2s ease-in-out infinite alternate;
        }
        
        @keyframes glow {
            from {
                box-shadow: 0 0 5px var(--neon-blue), 0 0 10px var(--neon-blue);
            }
            to {
                box-shadow: 0 0 10px var(--neon-blue), 0 0 20px var(--neon-blue), 0 0 30px var(--neon-purple);
            }
        }
        
        .floating {
            animation: floating 3s ease-in-out infinite;
        }
        
        @keyframes floating {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0px); }
        }
        
        .glitch {
            position: relative;
        }
        
        .glitch::after {
            content: attr(data-text);
            position: absolute;
            left: 2px;
            top: 0;
            color: var(--neon-pink);
            background: var(--dark-bg);
            overflow: hidden;
            clip: rect(0, 900px, 0, 0);
            animation: noise-anim 2s infinite linear alternate-reverse;
        }
        
        .glitch::before {
            content: attr(data-text);
            position: absolute;
            left: -2px;
            top: 0;
            color: var(--neon-blue);
            background: var(--dark-bg);
            overflow: hidden;
            clip: rect(0, 900px, 0, 0);
            animation: noise-anim-2 3s infinite linear alternate-reverse;
        }
        
        @keyframes noise-anim {
            0% { clip: rect(41px, 9999px, 19px, 0); }
            10% { clip: rect(84px, 9999px, 28px, 0); }
            20% { clip: rect(19px, 9999px, 18px, 0); }
            30% { clip: rect(57px, 9999px, 44px, 0); }
            40% { clip: rect(19px, 9999px, 38px, 0); }
            50% { clip: rect(83px, 9999px, 38px, 0); }
            60% { clip: rect(4px, 9999px, 55px, 0); }
            70% { clip: rect(51px, 9999px, 9px, 0); }
            80% { clip: rect(66px, 9999px, 16px, 0); }
            90% { clip: rect(37px, 9999px, 28px, 0); }
            100% { clip: rect(79px, 9999px, 44px, 0); }
        }
        
        @keyframes noise-anim-2 {
            0% { clip: rect(18px, 9999px, 36px, 0); }
            15% { clip: rect(32px, 9999px, 15px, 0); }
            30% { clip: rect(50px, 9999px, 10px, 0); }
            45% { clip: rect(20px, 9999px, 35px, 0); }
            60% { clip: rect(67px, 9999px, 27px, 0); }
            75% { clip: rect(13px, 9999px, 50px, 0); }
            100% { clip: rect(44px, 9999px, 16px, 0); }
        }
    </style>
</head>
<body class="relative min-h-screen flex flex-col items-center justify-center p-4">
    <!-- –°–∫–∞–Ω-–ª–∏–Ω–∏–∏ –¥–ª—è —ç—Ñ—Ñ–µ–∫—Ç–∞ CRT -->
    <div class="scanline"></div>
    
    <!-- –ë–æ–∫–æ–≤—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã –¥–µ–∫–æ—Ä–∞ -->
    <div class="absolute left-0 top-0 h-full w-16 flex flex-col items-center justify-around py-20">
        <div class="w-12 h-16 neon-border-blue bg-black bg-opacity-60 rounded-md"></div>
        <div class="w-8 h-32 neon-border-pink bg-black bg-opacity-60 rounded-md"></div>
        <div class="w-10 h-20 neon-border-blue bg-black bg-opacity-60 rounded-md"></div>
    </div>
    
    <div class="absolute right-0 top-0 h-full w-16 flex flex-col items-center justify-around py-20">
        <div class="w-10 h-20 neon-border-blue bg-black bg-opacity-60 rounded-md"></div>
        <div class="w-8 h-32 neon-border-pink bg-black bg-opacity-60 rounded-md"></div>
        <div class="w-12 h-16 neon-border-blue bg-black bg-opacity-60 rounded-md"></div>
    </div>
    
    <!-- –û—Å–Ω–æ–≤–Ω–æ–π –∫–æ–Ω—Ç–µ–Ω—Ç -->
    <div class="z-10 flex flex-col md:flex-row items-center justify-center gap-8">
        <!-- –õ–µ–≤–∞—è –ø–∞–Ω–µ–ª—å —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π -->
        <div class="neon-border-blue bg-black bg-opacity-70 p-6 rounded-lg w-64 h-96 flex flex-col justify-between">
            <div>
                <h1 class="glitch text-3xl mb-6 text-center" data-text="CYBER TETRIS">CYBER TETRIS</h1>
                <div class="mb-6">
                    <div class="flex justify-between items-center mb-2">
                        <span class="neon-text-pink">SCORE:</span>
                        <span id="score" class="neon-text-blue">0</span>
                    </div>
                    <div class="flex justify-between items-center mb-2">
                        <span class="neon-text-pink">LEVEL:</span>
                        <span id="level" class="neon-text-blue">1</span>
                    </div>
                    <div class="flex justify-between items-center">
                        <span class="neon-text-pink">LINES:</span>
                        <span id="lines" class="neon-text-blue">0</span>
                    </div>
                </div>
            </div>
            
            <div class="mb-6">
                <h3 class="neon-text-pink text-lg mb-2">CONTROLS:</h3>
                <ul class="space-y-1 text-sm">
                    <li class="flex items-center"><i class="fas fa-arrow-left mr-2 neon-text-blue"></i> <span>Move Left</span></li>
                    <li class="flex items-center"><i class="fas fa-arrow-right mr-2 neon-text-blue"></i> <span>Move Right</span></li>
                    <li class="flex items-center"><i class="fas fa-arrow-down mr-2 neon-text-blue"></i> <span>Soft Drop</span></li>
                    <li class="flex items-center"><i class="fas fa-arrow-up mr-2 neon-text-blue"></i> <span>Rotate</span></li>
                    <li class="flex items-center"><i class="fas fa-space-shuttle mr-2 neon-text-blue"></i> <span>Hard Drop</span></li>
                    <li class="flex items-center"><i class="fas fa-pause mr-2 neon-text-blue"></i> <span>Pause</span></li>
                </ul>
            </div>
            
            <button id="start-btn" class="neon-border-pink neon-text-pink hover:bg-pink-900 hover:bg-opacity-30 py-2 px-4 rounded-md transition-all duration-300 glow">
                START GAME
            </button>
        </div>
        
        <!-- –ò–≥—Ä–æ–≤–æ–µ –ø–æ–ª–µ -->
        <div class="relative">
            <div class="neon-border-blue bg-black bg-opacity-70">
                <div id="grid" class="grid grid-cols-10 grid-rows-20 gap-0"></div>
            </div>
            
            <!-- –ó–∞—Ç–µ–º–Ω–µ–Ω–∏–µ –ø—Ä–∏ –ø–∞—É–∑–µ -->
            <div id="pause-overlay" class="absolute inset-0 bg-black bg-opacity-70 flex flex-col items-center justify-center hidden">
                <h2 class="neon-text-pink text-4xl mb-6">PAUSED</h2>
                <button class="neon-border-blue neon-text-blue hover:bg-blue-900 hover:bg-opacity-30 py-2 px-6 rounded-md transition-all duration-300">
                    CONTINUE
                </button>
            </div>
            
            <!-- –ó–∞—Ç–µ–º–Ω–µ–Ω–∏–µ –ø—Ä–∏ Game Over -->
            <div id="game-over-overlay" class="absolute inset-0 bg-black bg-opacity-70 flex flex-col items-center justify-center hidden">
                <h2 class="neon-text-pink text-4xl mb-4 glitch" data-text="GAME OVER">GAME OVER</h2>
                <p class="neon-text-blue mb-6">SCORE: <span id="final-score">0</span></p>
                <button class="neon-border-blue neon-text-blue hover:bg-blue-900 hover:bg-opacity-30 py-2 px-6 rounded-md transition-all duration-300">
                    PLAY AGAIN
                </button>
            </div>
        </div>
        
        <!-- –ü–∞–Ω–µ–ª—å —Å–ª–µ–¥—É—é—â–µ–π —Ñ–∏–≥—É—Ä—ã -->
        <div class="neon-border-blue bg-black bg-opacity-70 p-4 rounded-lg w-32 h-32 flex flex-col items-center">
            <h3 class="neon-text-pink text-lg mb-2">NEXT:</h3>
            <div id="next-piece" class="grid grid-cols-4 grid-rows-4 gap-0 w-24 h-24"></div>
        </div>
    </div>
    
    <!-- –î–µ–∫–æ—Ä–∞—Ç–∏–≤–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç –≤–Ω–∏–∑—É -->
    <div class="absolute bottom-4 left-0 right-0 flex justify-center">
        <div class="w-3/4 h-1 neon-border-pink bg-black bg-opacity-60 flex">
            <div class="h-full w-1/4 bg-neon-pink bg-opacity-30 animate-pulse"></div>
        </div>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã –∏–≥—Ä—ã
            const COLS = 10;
            const ROWS = 20;
            const EMPTY = 0;
            const BLOCK_SIZE = 30;
            
            // –§–∏–≥—É—Ä—ã —Ç–µ—Ç—Ä–∏—Å–∞
            const SHAPES = [
                [[1, 1, 1, 1]],                       // I
                [[1, 1, 1], [0, 0, 1]],               // J
                [[1, 1, 1], [1, 0, 0]],               // L
                [[1, 1], [1, 1]],                     // O
                [[0, 1, 1], [1, 1, 0]],               // S
                [[0, 1, 0], [1, 1, 1]],               // T
                [[1, 1, 0], [0, 1, 1]]                // Z
            ];
            
            const COLORS = [
                '#00f7ff',  // I - –≥–æ–ª—É–±–æ–π
                '#0d00ff',  // J - —Å–∏–Ω–∏–π
                '#ff8800',  // L - –æ—Ä–∞–Ω–∂–µ–≤—ã–π
                '#ffee00',  // O - –∂–µ–ª—Ç—ã–π
                '#00ff4c',  // S - –∑–µ–ª–µ–Ω—ã–π
                '#b700ff',  // T - —Ñ–∏–æ–ª–µ—Ç–æ–≤—ã–π
                '#ff0000'   // Z - –∫—Ä–∞—Å–Ω—ã–π
            ];
            
            const CLASSES = [
                'piece-i', 'piece-j', 'piece-l', 'piece-o', 'piece-s', 'piece-t', 'piece-z'
            ];
            
            // –≠–ª–µ–º–µ–Ω—Ç—ã DOM
            const gridElement = document.getElementById('grid');
            const nextPieceElement = document.getElementById('next-piece');
            const scoreElement = document.getElementById('score');
            const levelElement = document.getElementById('level');
            const linesElement = document.getElementById('lines');
            const startButton = document.getElementById('start-btn');
            const pauseOverlay = document.getElementById('pause-overlay');
            const gameOverOverlay = document.getElementById('game-over-overlay');
            
            // –°–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã
            let grid = createGrid(ROWS, COLS);
            let piece = null;
            let nextPiece = null;
            let score = 0;
            let level = 1;
            let lines = 0;
            let gameLoop = null;
            let isPaused = false;
            let isGameOver = false;
            let dropCounter = 0;
            let dropInterval = 1000; // –ù–∞—á–∞–ª—å–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å –ø–∞–¥–µ–Ω–∏—è
            let lastTime = 0;
            let ghostPiecePosition = null;
            
            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏–≥—Ä–æ–≤–æ–≥–æ –ø–æ–ª—è
            function createGrid(rows, cols) {
                const grid = [];
                for (let r = 0; r < rows; r++) {
                    grid.push(new Array(cols).fill(EMPTY));
                }
                return grid;
            }
            
            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏–≥—Ä–æ–≤—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤
            function init() {
                // –°–æ–∑–¥–∞–µ–º –∫–ª–µ—Ç–∫–∏ –∏–≥—Ä–æ–≤–æ–≥–æ –ø–æ–ª—è
                gridElement.innerHTML = '';
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        const cell = document.createElement('div');
                        cell.classList.add('grid-cell');
                        cell.setAttribute('data-row', r);
                        cell.setAttribute('data-col', c);
                        gridElement.appendChild(cell);
                    }
                }
                
                // –°–æ–∑–¥–∞–µ–º –∫–ª–µ—Ç–∫–∏ –¥–ª—è —Å–ª–µ–¥—É—é—â–µ–π —Ñ–∏–≥—É—Ä—ã
                nextPieceElement.innerHTML = '';
                for (let r = 0; r < 4; r++) {
                    for (let c = 0; c < 4; c++) {
                        const cell = document.createElement('div');
                        cell.classList.add('grid-cell');
                        cell.setAttribute('data-row', r);
                        cell.setAttribute('data-col', c);
                        nextPieceElement.appendChild(cell);
                    }
                }
            }
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–π —Ñ–∏–≥—É—Ä—ã
            function createPiece(type) {
                const shape = SHAPES[type];
                const color = COLORS[type];
                const x = Math.floor(COLS / 2) - Math.floor(shape[0].length / 2);
                const y = -2; // –ù–∞—á–∏–Ω–∞–µ–º –Ω–µ–º–Ω–æ–≥–æ –≤—ã—à–µ –ø–æ–ª—è
                
                return {
                    x,
                    y,
                    shape,
                    color,
                    type,
                    width: shape[0].length,
                    height: shape.length
                };
            }
            
            // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –∏–≥—Ä–æ–≤–æ–≥–æ –ø–æ–ª—è
            function draw() {
                // –û—á–∏—â–∞–µ–º –∏–≥—Ä–æ–≤–æ–µ –ø–æ–ª–µ
                const cells = document.querySelectorAll('#grid .grid-cell');
                cells.forEach(cell => {
                    cell.className = 'grid-cell';
                    cell.style.backgroundColor = '';
                });
                
                // –û—Ç—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º –∑–∞–∫—Ä–µ–ø–ª–µ–Ω–Ω—ã–µ —Ñ–∏–≥—É—Ä—ã
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        if (grid[r][c] !== EMPTY) {
                            const index = (r * COLS) + c;
                            cells[index].classList.add(CLASSES[grid[r][c] - 1]);
                        }
                    }
                }
                
                // –û—Ç—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º —Ç–µ–∫—É—â—É—é —Ñ–∏–≥—É—Ä—É
                if (piece) {
                    drawPiece(piece);
                    
                    // –û—Ç—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º "—Ç–µ–Ω–µ–≤—É—é" —Ñ–∏–≥—É—Ä—É (ghost piece)
                    if (ghostPiecePosition) {
                        drawGhostPiece(ghostPiecePosition);
                    }
                }
                
                // –û—Ç—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º —Å–ª–µ–¥—É—é—â—É—é —Ñ–∏–≥—É—Ä—É
                if (nextPiece) {
                    drawNextPiece(nextPiece);
                }
            }
            
            // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ —Ç–µ–∫—É—â–µ–π —Ñ–∏–≥—É—Ä—ã
            function drawPiece(piece) {
                const cells = document.querySelectorAll('#grid .grid-cell');
                
                for (let r = 0; r < piece.shape.length; r++) {
                    for (let c = 0; c < piece.shape[r].length; c++) {
                        if (piece.shape[r][c]) {
                            const gridRow = piece.y + r;
                            const gridCol = piece.x + c;
                            
                            if (gridRow >= 0 && gridRow < ROWS && gridCol >= 0 && gridCol < COLS) {
                                const index = (gridRow * COLS) + gridCol;
                                cells[index].classList.add(CLASSES[piece.type]);
                            }
                        }
                    }
                }
            }
            
            // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ "—Ç–µ–Ω–µ–≤–æ–π" —Ñ–∏–≥—É—Ä—ã
            function drawGhostPiece(ghostPos) {
                const cells = document.querySelectorAll('#grid .grid-cell');
                cells.forEach(cell => cell.classList.remove('piece-ghost'));
                
                for (let r = 0; r < piece.shape.length; r++) {
                    for (let c = 0; c < piece.shape[r].length; c++) {
                        if (piece.shape[r][c]) {
                            const gridRow = ghostPos.y + r;
                            const gridCol = ghostPos.x + c;
                            
                            if (gridRow >= 0 && gridRow < ROWS && gridCol >= 0 && gridCol < COLS) {
                                const index = (gridRow * COLS) + gridCol;
                                if (grid[gridRow][gridCol] === EMPTY) {
                                    cells[index].classList.add('piece-ghost');
                                    cells[index].classList.add(CLASSES[piece.type]);
                                }
                            }
                        }
                    }
                }
            }
            
            // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ —Å–ª–µ–¥—É—é—â–µ–π —Ñ–∏–≥—É—Ä—ã
            function drawNextPiece(piece) {
                const cells = document.querySelectorAll('#next-piece .grid-cell');
                cells.forEach(cell => {
                    cell.className = 'grid-cell';
                    cell.style.backgroundColor = '';
                });
                
                // –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º —Ñ–∏–≥—É—Ä—É –≤ preview
                const offsetX = Math.floor((4 - piece.shape[0].length) / 2);
                const offsetY = Math.floor((4 - piece.shape.length) / 2);
                
                for (let r = 0; r < piece.shape.length; r++) {
                    for (let c = 0; c < piece.shape[r].length; c++) {
                        if (piece.shape[r][c]) {
                            const gridRow = offsetY + r;
                            const gridCol = offsetX + c;
                            const index = (gridRow * 4) + gridCol;
                            cells[index].classList.add(CLASSES[piece.type]);
                        }
                    }
                }
            }
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—á–µ—Ç–∞ –∏ —É—Ä–æ–≤–Ω—è
            function updateScore(linesCleared) {
                // –û—á–∫–∏ –∑–∞ –æ—á–∏—â–µ–Ω–Ω—ã–µ –ª–∏–Ω–∏–∏
                const linePoints = [0, 40, 100, 300, 1200];
                score += linePoints[linesCleared] * level;
                lines += linesCleared;
                
                // –£—Ä–æ–≤–µ–Ω—å —É–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç—Å—è –∫–∞–∂–¥—ã–µ 10 –ª–∏–Ω–∏–π
                level = Math.floor(lines / 10) + 1;
                
                // –£–º–µ–Ω—å—à–∞–µ–º –∏–Ω—Ç–µ—Ä–≤–∞–ª –ø–∞–¥–µ–Ω–∏—è —Å —É–≤–µ–ª–∏—á–µ–Ω–∏–µ–º —É—Ä–æ–≤–Ω—è
                dropInterval = Math.max(100, 1000 - (level - 1) * 100);
                
                // –û–±–Ω–æ–≤–ª—è–µ–º UI
                scoreElement.textContent = score;
                levelElement.textContent = level;
                linesElement.textContent = lines;
            }
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π
            function isCollision(piece, offsetX = 0, offsetY = 0) {
                for (let r = 0; r < piece.shape.length; r++) {
                    for (let c = 0; c < piece.shape[r].length; c++) {
                        if (piece.shape[r][c]) {
                            const newX = piece.x + c + offsetX;
                            const newY = piece.y + r + offsetY;
                            
                            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—ã—Ö–æ–¥–∞ –∑–∞ –≥—Ä–∞–Ω–∏—Ü—ã –ø–æ–ª—è
                            if (newX < 0 || newX >= COLS || newY >= ROWS) {
                                return true;
                            }
                            
                            // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏—è —Å –∑–∞–∫—Ä–µ–ø–ª–µ–Ω–Ω—ã–º–∏ —Ñ–∏–≥—É—Ä–∞–º–∏
                            if (newY >= 0 && grid[newY][newX] !== EMPTY) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }
            
            // –û—á–∏—Å—Ç–∫–∞ –∑–∞–ø–æ–ª–Ω–µ–Ω–Ω—ã—Ö –ª–∏–Ω–∏–π
            function clearLines() {
                let linesCleared = 0;
                
                for (let r = ROWS - 1; r >= 0; r--) {
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∑–∞–ø–æ–ª–Ω–µ–Ω–∞ –ª–∏ —Å—Ç—Ä–æ–∫–∞
                    const isLineFull = grid[r].every(cell => cell !== EMPTY);
                    
                    if (isLineFull) {
                        linesCleared++;
                        
                        // –£–¥–∞–ª—è–µ–º —Å—Ç—Ä–æ–∫—É –∏ –¥–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—É—é –ø—É—Å—Ç—É—é —Å–≤–µ—Ä—Ö—É
                        grid.splice(r, 1);
                        grid.unshift(new Array(COLS).fill(EMPTY));
                        
                        // –ü–æ–≤—Ç–æ—Ä–Ω–æ –ø—Ä–æ–≤–µ—Ä—è–µ–º —ç—Ç—É –∂–µ —Å—Ç—Ä–æ–∫—É
                        r++;
                    }
                }
                
                if (linesCleared > 0) {
                    updateScore(linesCleared);
                    playSound('clear');
                }
            }
            
            // –ó–∞–∫—Ä–µ–ø–ª–µ–Ω–∏–µ —Ñ–∏–≥—É—Ä—ã –Ω–∞ –ø–æ–ª–µ
            function mergePiece() {
                for (let r = 0; r < piece.shape.length; r++) {
                    for (let c = 0; c < piece.shape[r].length; c++) {
                        if (piece.shape[r][c]) {
                            const gridRow = piece.y + r;
                            const gridCol = piece.x + c;
                            
                            if (gridRow >= 0 && gridRow < ROWS && gridCol >= 0 && gridCol < COLS) {
                                grid[gridRow][gridCol] = piece.type + 1; // +1 –ø–æ—Ç–æ–º—É —á—Ç–æ EMPTY = 0
                            }
                        }
                    }
                }
            }
            
            // –ü–æ–≤–æ—Ä–æ—Ç —Ñ–∏–≥—É—Ä—ã
            function rotate() {
                if (!piece || isGameOver || isPaused) return;
                
                const newShape = [];
                for (let c = 0; c < piece.width; c++) {
                    const newRow = [];
                    for (let r = piece.height - 1; r >= 0; r--) {
                        newRow.push(piece.shape[r][c]);
                    }
                    newShape.push(newRow);
                }
                
                const originalShape = piece.shape;
                piece.shape = newShape;
                piece.width = piece.shape[0].length;
                piece.height = piece.shape.length;
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –º–æ–∂–Ω–æ –ª–∏ –ø–æ–≤–µ—Ä–Ω—É—Ç—å
                if (isCollision(piece)) {
                    // –ü—ã—Ç–∞–µ–º—Å—è —Å–¥–µ–ª–∞—Ç—å wall kick (—Å–¥–≤–∏–≥ —Ñ–∏–≥—É—Ä—ã, —á—Ç–æ–±—ã –ø–æ–≤–µ—Ä–Ω—É—Ç—å —É —Å—Ç–µ–Ω—ã)
                    if (piece.x + piece.width > COLS) {
                        piece.x = COLS - piece.width;
                    }
                    
                    if (piece.x < 0) {
                        piece.x = 0;
                    }
                    
                    // –ï—Å–ª–∏ –≤—Å–µ —Ä–∞–≤–Ω–æ –Ω–µ–ª—å–∑—è –ø–æ–≤–µ—Ä–Ω—É—Ç—å, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –∏—Å—Ö–æ–¥–Ω—É—é —Ñ–æ—Ä–º—É
                    if (isCollision(piece)) {
                        piece.shape = originalShape;
                        piece.width = piece.shape[0].length;
                        piece.height = piece.shape.length;
                    }
                }
                
                playSound('rotate');
                updateGhostPiece();
                draw();
            }
            
            // –î–≤–∏–∂–µ–Ω–∏–µ —Ñ–∏–≥—É—Ä—ã –≤–ª–µ–≤–æ
            function moveLeft() {
                if (!piece || isGameOver || isPaused) return;
                
                if (!isCollision(piece, -1)) {
                    piece.x--;
                    updateGhostPiece();
                    draw();
                }
                playSound('move');
            }
            
            // –î–≤–∏–∂–µ–Ω–∏–µ —Ñ–∏–≥—É—Ä—ã –≤–ø—Ä–∞–≤–æ
            function moveRight() {
                if (!piece || isGameOver || isPaused) return;
                
                if (!isCollision(piece, 1)) {
                    piece.x++;
                    updateGhostPiece();
                    draw();
                }
                playSound('move');
            }
            
            // –ú—è–≥–∫–æ–µ –ø–∞–¥–µ–Ω–∏–µ (—É—Å–∫–æ—Ä–µ–Ω–Ω–æ–µ –≤–Ω–∏–∑)
            function softDrop() {
                if (!piece || isGameOver || isPaused) return;
                
                if (!isCollision(piece, 0, 1)) {
                    piece.y++;
                    dropCounter = 0; // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—á–µ—Ç—á–∏–∫ –ø–∞–¥–µ–Ω–∏—è
                    draw();
                }
                playSound('drop');
            }
            
            // –ñ–µ—Å—Ç–∫–æ–µ –ø–∞–¥–µ–Ω–∏–µ (–º–≥–Ω–æ–≤–µ–Ω–Ω–æ–µ –ø–∞–¥–µ–Ω–∏–µ)
            function hardDrop() {
                if (!piece || isGameOver || isPaused) return;
                
                while (!isCollision(piece, 0, 1)) {
                    piece.y++;
                }
                
                dropCounter = dropInterval; // –§–æ—Ä—Å–∏—Ä—É–µ–º –æ–±—Ä–∞–±–æ—Ç–∫—É –ø–∞–¥–µ–Ω–∏—è
                playSound('harddrop');
            }
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏ "—Ç–µ–Ω–µ–≤–æ–π" —Ñ–∏–≥—É—Ä—ã
            function updateGhostPiece() {
                if (!piece) return;
                
                ghostPiecePosition = { ...piece };
                
                while (!isCollision(ghostPiecePosition, 0, 1)) {
                    ghostPiecePosition.y++;
                }
            }
            
            // –ó–≤—É–∫–æ–≤—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã
            function playSound(type) {
                // –í —Ä–µ–∞–ª—å–Ω–æ–π –∏–≥—Ä–µ –∑–¥–µ—Å—å –±—É–¥–µ—Ç –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –∑–≤—É–∫–∞
                // console.log('Playing sound:', type);
            }
            
            // –ü–∞—É–∑–∞ –∏–≥—Ä—ã
            function togglePause() {
                if (isGameOver) return;
                
                isPaused = !isPaused;
                
                if (isPaused) {
                    pauseOverlay.classList.remove('hidden');
                } else {
                    pauseOverlay.classList.add('hidden');
                    lastTime = performance.now(); // –°–±—Ä–æ—Å —Ç–∞–π–º–µ—Ä–∞ –ø–æ—Å–ª–µ –ø–∞—É–∑—ã
                }
            }
            
            // –ö–æ–Ω–µ—Ü –∏–≥—Ä—ã
            function gameOver() {
                isGameOver = true;
                document.getElementById('final-score').textContent = score;
                gameOverOverlay.classList.remove('hidden');
                clearInterval(gameLoop);
                playSound('gameover');
            }
            
            // –°–±—Ä–æ—Å –∏–≥—Ä—ã
            function resetGame() {
                grid = createGrid(ROWS, COLS);
                piece = null;
                nextPiece = null;
                score = 0;
                level = 1;
                lines = 0;
                dropInterval = 1000;
                isGameOver = false;
                isPaused = false;
                lastTime = 0;
                dropCounter = 0;
                
                scoreElement.textContent = score;
                levelElement.textContent = level;
                linesElement.textContent = lines;
                
                gameOverOverlay.classList.add('hidden');
                pauseOverlay.classList.add('hidden');
                
                // –°–æ–∑–¥–∞–µ–º –ø–µ—Ä–≤—É—é —Ñ–∏–≥—É—Ä—É
                nextPiece = createPiece(Math.floor(Math.random() * SHAPES.length));
                spawnPiece();
                
                // –ó–∞–ø—É—Å–∫–∞–µ–º –∏–≥—Ä–æ–≤–æ–π —Ü–∏–∫–ª
                if (gameLoop) clearInterval(gameLoop);
                lastTime = performance.now();
                gameLoop = requestAnimationFrame(update);
            }
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–π —Ñ–∏–≥—É—Ä—ã
            function spawnPiece() {
                if (nextPiece) {
                    piece = nextPiece;
                    nextPiece = createPiece(Math.floor(Math.random() * SHAPES.length));
                } else {
                    piece = createPiece(Math.floor(Math.random() * SHAPES.length));
                    nextPiece = createPiece(Math.floor(Math.random() * SHAPES.length));
                }
                
                updateGhostPiece();
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º game over
                if (isCollision(piece)) {
                    gameOver();
                }
            }
            
            // –ì–ª–∞–≤–Ω—ã–π –∏–≥—Ä–æ–≤–æ–π —Ü–∏–∫–ª
            function update(time = 0) {
                if (isPaused || isGameOver) {
                    lastTime = time;
                    gameLoop = requestAnimationFrame(update);
                    return;
                }
                
                const deltaTime = time - lastTime;
                lastTime = time;
                
                dropCounter += deltaTime;
                
                if (dropCounter > dropInterval) {
                    if (!isCollision(piece, 0, 1)) {
                        piece.y++;
                    } else {
                        // –§–∏–≥—É—Ä–∞ –¥–æ—Å—Ç–∏–≥–ª–∞ –¥–Ω–∞
                        mergePiece();
                        clearLines();
                        spawnPiece();
                    }
                    
                    dropCounter = 0;
                }
                
                draw();
                gameLoop = requestAnimationFrame(update);
            }
            
            // –û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞–∂–∞—Ç–∏–π –∫–ª–∞–≤–∏—à
            function handleKeyDown(e) {
                if (isGameOver) return;
                
                switch (e.key) {
                    case 'ArrowLeft':
                        moveLeft();
                        break;
                    case 'ArrowRight':
                        moveRight();
                        break;
                    case 'ArrowDown':
                        softDrop();
                        break;
                    case 'ArrowUp':
                        rotate();
                        break;
                    case ' ':
                        hardDrop();
                        break;
                    case 'p':
                    case 'P':
                        togglePause();
                        break;
                }
            }
            
            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏–≥—Ä—ã
            function startGame() {
                resetGame();
                startButton.textContent = 'RESTART';
            }
            
            // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Å–æ–±—ã—Ç–∏–π
            startButton.addEventListener('click', startGame);
            document.addEventListener('keydown', handleKeyDown);
            pauseOverlay.querySelector('button').addEventListener('click', togglePause);
            gameOverOverlay.querySelector('button').addEventListener('click', resetGame);
            
            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è UI
            init();
            
            // –î–æ–±–∞–≤–ª—è–µ–º —ç—Ñ—Ñ–µ–∫—Ç –Ω–∞–≤–µ–¥–µ–Ω–∏—è –¥–ª—è –∫–Ω–æ–ø–æ–∫
            const buttons = document.querySelectorAll('button');
            buttons.forEach(button => {
                button.addEventListener('mouseenter', () => {
                    playSound('hover');
                });
            });
        });
    </script>
<p style="border-radius: 8px; text-align: center; font-size: 12px; color: #fff; margin-top: 16px;position: fixed; left: 8px; bottom: 8px; z-index: 10; background: rgba(0, 0, 0, 0.8); padding: 4px 8px;">Made with <img src="https://enzostvs-deepsite.hf.space/logo.svg" alt="DeepSite Logo" style="width: 16px; height: 16px; vertical-align: middle;display:inline-block;margin-right:3px;filter:brightness(0) invert(1);"><a href="https://enzostvs-deepsite.hf.space" style="color: #fff;text-decoration: underline;" target="_blank" >DeepSite</a> - <a href="https://enzostvs-deepsite.hf.space?remix=mrwildoswildos/kiber-tetris" style="color: #fff;text-decoration: underline;" target="_blank" >üß¨ Remix</a></p></body>
</html>